# order-service homework

This project uses Quarkus, the Supersonic Subatomic Java Framework. It was a homework assignment, mainly focusing on AI collaboration.

## Setup instructions (mainly generated by Quarkus CLI)

Requirements: Java 21+. (Or just set the code compatibility level to a lower version in `build.gradle`, I don't think the code uses any newer features.)

### Running the application in dev mode

You can run your application in dev mode that enables live coding using:

```shell script
./gradlew quarkusDev
```

> **_NOTE:_**  Quarkus now ships with a Dev UI, which is available in dev mode only at <http://localhost:8080/q/dev/>.

### Packaging and running the application

The application can be packaged using:

```shell script
./gradlew build
```

It produces the `quarkus-run.jar` file in the `build/quarkus-app/` directory.
Be aware that it’s not an _über-jar_ as the dependencies are copied into the `build/quarkus-app/lib/` directory.

The application is now runnable using `java -jar build/quarkus-app/quarkus-run.jar`.

If you want to build an _über-jar_, execute the following command:

```shell script
./gradlew build -Dquarkus.package.jar.type=uber-jar
```

The application, packaged as an _über-jar_, is now runnable using `java -jar build/*-runner.jar`.

### Creating a native executable

You can create a native executable using:

```shell script
./gradlew build -Dquarkus.native.enabled=true
```

Or, if you don't have GraalVM installed, you can run the native executable build in a container using:

```shell script
./gradlew build -Dquarkus.native.enabled=true -Dquarkus.native.container-build=true
```

You can then execute your native executable with: `./build/hello-service-1.0.0-SNAPSHOT-runner`

If you want to learn more about building native executables, please consult <https://quarkus.io/guides/gradle-tooling>.

## Architectural decisions

According to the problem description this is supposed to emulate a carve out of the order microservice from a monolithic e-commerce application. Most of the architectural decisions were technical choices (see below). The ones that weren't technical are:

- The requirements needed an order entity. No further specifications. I decided to include an order ID, a customer ID, a creation date, a total price, order items, order status, and a billing and a shipping address. This is arbitrary for a minimal example. Mostly based on my personal experience in e-commerce. It's supposed to be easily extendable as needed.
- IDs are UUIDs, as those allow better scaling not creating a bottleneck with a single point of sequencial ID generation. In my experience it also makes the services more independent of each other.
- The requirements needed REST endpoints. In a read world application some of these should not be REST endpoints, as they don't need to be synchronous and an event driven design allows for better decoupling of the microservices. For example order creation would probably still remain a REST call, because if a customer places an order on the UI, they need confirmation that the order was placed. However, order status updates, such as a successful payment that makes the order processable is not needed to be a synchronous call from the payment service. It can be an event arriving from e.g. Kafka, and it can be processed at the order service's convenience. Similarly when the logistics service shipped the order, that could be just a notification coming through messaging.

## Technology choices justification

- The project uses Java 21, because that is the latest LTS version. Also because that's what I had installed on my machine.
- Quarkus was choosen for the promise that it's less resource heavy than Spring Boot. Also I've never worked with Quarkus before, and I really wanted the learning experience.
- The project uses Gradle for build automation. That's purely a personal preference, I'm less familiar with Maven, but I also find Gradle settings more readable.
- It's a multi-module project, because I strongly believe in the separation of concerns. I also trust neither myself, nor the LLM to not make a mess of the dependencies if the structure is not enforced.
- Hexagonal Architecture was choosen because it's a good fit for microservices. It further emphasizes the separation of concerns, but is not as heavy on abstraction as Clean Architecture.

## AI collaboration report

The report can be found in the same repository at: [https://github.com/balazsmiklos85/vibe_homework/blob/main/doc/ai_collaboration_documentation.md]

Interactions with LLMs are also contained here: [https://github.com/balazsmiklos85/vibe_homework/tree/main/doc/llm_interactions]
